# Git
wip() {
    git add .
    git commit -m "WIP"
}

gcrb() {
    [[ -z "$1" ]] && { echo "Commit hash missing"; return 1; }

    git commit --fixup=$1

    local stash_created=0
    if [[ -n "$(git status --porcelain)" ]]; then
        git stash push --keep-index -m "Stashing changes before rebase"
        stash_created=1
    fi

    GIT_SEQUENCE_EDITOR=true git rebase -i --autosquash $1^

    [[ "$stash_created" -eq 1 ]] && git stash pop
}

tagandrelease() {
    git tag -a "$1" -m "$1" && git push upstream "$1" && gh release create "$1" --generate-notes
}

untagandunrelease() {
    gh release delete "$1" --yes && git push upstream --delete "$1" && git tag -d "$1"
}

glb() {
    local branch
    branch=$(git lb | fzf --ansi --height 20 --reverse | awk '{print $NF}')
    [[ -n "$branch" ]] && git checkout "$branch"
}

# Symfony
ss() {
    APP_ENV=${1:-dev} symfony serve -d
}

sss() {
    symfony server:stop
}

cc() {
    if [[ -d "var" ]]; then
        rm -fr var/cache
        php -dxdebug.mode=off symfony console
    elif [[ -d "tests/Application" ]]; then
        cd tests/Application && rm -fr var/cache && symfony console
    else
        echo "Wrong directory"
    fi
}

dbc() {
    bin/console doctrine:database:drop --force --if-exists
    bin/console doctrine:database:create
    bin/console doctrine:migrations:migrate -n
    bin/console sylius:fixtures:load $1 -n
}

dbct() {
    bin/console doctrine:database:create --if-not-exists --env=test
    bin/console doctrine:schema:update --force --env=test
}

# Yarn
uberyarn() {
    rm -fr node_modules/.cache public/build
    yarn install
    yarn build
}

# Reset project
cofankolite() {
    git restore --staged .
    git restore .
    git clean -fd
}

cofanko() {
    cofankolite
    composer update
    bin/console doctrine:database:drop --if-exists --force
    bin/console doctrine:database:create --if-not-exists
    bin/console doctrine:migrations:migrate -n
}

# Xdebug
phpstorm() {
    export XDEBUG_SESSION_START=phpstorm
    export XDEBUG_CONFIG="idkey=PHPSTORM"
    export XDEBUG_SESSION=xdebug_is_great
}

xdebugoff() {
    unset XDEBUG_SESSION_START
    unset XDEBUG_CONFIG
    unset XDEBUG_SESSION
}

# Interactive env selector
setenv() {
    local env="$1"
    if [ -z "$env" ]; then
        env=$(echo -e "dev\ntest\nprod" | fzf --height=40% --prompt="APP_ENV: " --no-info --pointer=' ' --color='fg:8,fg+:15,bg+:-1,hl:6,hl+:14')
    fi
    if [ -n "$env" ]; then
        export APP_ENV="$env"
        echo "APP_ENV=$env"
    fi
}

# Clear env (use .env defaults)
clearenv() {
    unset APP_ENV
    echo "APP_ENV cleared (using .env defaults)"
}

# Interactive database name change in .env.local
setdb() {
    [[ ! -f .env.local ]] && { echo "No .env.local found"; return 1; }

    local current=$(grep '^DATABASE_URL=' .env.local | head -1)
    echo "Current: $current"
    echo ""

    read "newdb?New database name (or empty to cancel): "
    [[ -z "$newdb" ]] && { echo "Cancelled"; return 0; }

    # Get current URL structure, replace db name
    local prefix=$(echo "$current" | sed -E 's|(DATABASE_URL=.*/)([^?]+)(.*)|\1|')
    local suffix=$(echo "$current" | sed -E 's|(DATABASE_URL=.*/)([^?]+)(.*)|\3|')

    local newline="${prefix}${newdb}${suffix}"

    # Replace in .env.local
    sed -i '' "s|^DATABASE_URL=.*|$newline|" .env.local

    echo "Updated: $newline"
}

# Interactive project menu
setup() {
    local options=(
        "xdebug: $([ -n \"$XDEBUG_SESSION\" ] && echo 'OFF' || echo 'ON')"
        "env: dev"
        "env: test"
        "env: prod"
        "env: clear"
        "db: migrate"
        "db: reset (drop + migrate + fixtures)"
        "db: set name"
        "server: start"
        "server: stop"
        "docker: up"
        "docker: down"
        "cache: clear"
    )

    local choice=$(printf '%s\n' "${options[@]}" | fzf --height=40% --reverse --prompt="setup> " --no-info --pointer=' ' --color='fg:8,fg+:15,bg+:-1,hl:6,hl+:14')
    [[ -z "$choice" ]] && return 0

    case "$choice" in
        "xdebug: ON")  phpstorm && echo "Xdebug ON" ;;
        "xdebug: OFF") xdebugoff && echo "Xdebug OFF" ;;
        "env: dev")    export APP_ENV=dev && echo "APP_ENV=dev" ;;
        "env: test")   export APP_ENV=test && echo "APP_ENV=test" ;;
        "env: prod")   export APP_ENV=prod && echo "APP_ENV=prod" ;;
        "env: clear")  clearenv ;;
        "db: migrate") bin/console doctrine:migrations:migrate -n ;;
        "db: reset"*)  dbc ;;
        "db: set name") setdb ;;
        "server: start") ss ;;
        "server: stop")  sss ;;
        "docker: up")   docker compose up -d ;;
        "docker: down") docker compose down ;;
        "cache: clear") cc ;;
    esac
}

# Slash commands (type / at start of line)
_slash_commands() {
    local history_file="$HOME/.slash_history"
    local -A all_commands=(
        # Project commands
        ["/xdebug on"]="Enable xdebug"
        ["/xdebug off"]="Disable xdebug"
        ["/env dev"]="Set APP_ENV=dev"
        ["/env test"]="Set APP_ENV=test"
        ["/env prod"]="Set APP_ENV=prod"
        ["/env clear"]="Unset APP_ENV"
        ["/db migrate"]="Run migrations"
        ["/db reset"]="Drop + migrate + fixtures"
        ["/db name"]="Change database name"
        ["/db switch"]="Switch between MySQL and PostgreSQL"
        ["/server start"]="Start Symfony server"
        ["/server stop"]="Stop Symfony server"
        ["/docker up"]="Docker compose up -d"
        ["/docker down"]="Docker compose down"
        ["/docker ps"]="Docker compose ps"
        ["/cache"]="Clear cache"
        # Dotfiles commands
        ["/alias add"]="Add new alias"
        ["/alias list"]="Show all aliases"
        ["/func add"]="Add new function"
        ["/func list"]="Show all functions"
        ["/dot edit"]="Edit dotfiles in vim"
        ["/dot sync"]="Push dotfiles to remote"
        ["/reload"]="Reload shell config"
        ["/update"]="Update dotfiles from remote"
        # Setup commands
        ["/setup claude"]="Run Claude Code setup script"
        # Copy commands
        ["/copy path"]="Copy current directory to clipboard"
        # SSH commands
        ["/ssh keys"]="List SSH keys"
        ["/ssh agent"]="List keys in ssh-agent"
        ["/ssh add"]="Add key to ssh-agent"
        ["/ssh gen"]="Generate new SSH key"
        ["/ssh copy"]="Copy public key to clipboard"
        ["/ssh config"]="Edit SSH config"
        ["/ssh connect"]="Connect to host from config"
    )

    # Build list: recent first, then rest
    local commands=()
    local -A seen=()

    # Add recent commands first (from history, most recent first)
    if [[ -f "$history_file" ]]; then
        while IFS= read -r cmd; do
            if [[ -n "${all_commands[$cmd]}" && -z "${seen[$cmd]}" ]]; then
                commands+=("$cmd:${all_commands[$cmd]}")
                seen[$cmd]=1
            fi
        done < <(tail -20 "$history_file" | tail -r 2>/dev/null || tac 2>/dev/null || cat)
    fi

    # Add remaining commands
    for cmd in "${(@k)all_commands}"; do
        if [[ -z "${seen[$cmd]}" ]]; then
            commands+=("$cmd:${all_commands[$cmd]}")
        fi
    done

    local choice=$(printf '%s\n' "${commands[@]}" | awk -F: '{printf "%-20s\t%s\n", $1, $2}' | fzf \
        --height=40% \
        --layout=reverse-list \
        --prompt='/ ' \
        --delimiter=$'\t' \
        --bind='backward-eof:abort,tab:transform-query:echo {1} | sed "s|^/||"' \
        --no-info \
        --pointer=' ' \
        --marker=' ' \
        --color='fg:8,fg+:15,bg+:-1,hl:6,hl+:14,gutter:-1')
    local cmd=$(echo "$choice" | cut -f1 | xargs)

    [[ -z "$cmd" ]] && return

    # Save to history
    echo "$cmd" >> "$history_file"

    case "$cmd" in
        "/xdebug on")   phpstorm && echo "Xdebug ON" ;;
        "/xdebug off")  xdebugoff && echo "Xdebug OFF" ;;
        "/env dev")     export APP_ENV=dev && echo "APP_ENV=dev" ;;
        "/env test")    export APP_ENV=test && echo "APP_ENV=test" ;;
        "/env prod")    export APP_ENV=prod && echo "APP_ENV=prod" ;;
        "/env clear")   clearenv ;;
        "/db migrate")  bin/console doctrine:migrations:migrate -n ;;
        "/db reset")    dbc ;;
        "/db name")     setdb ;;
        "/db switch")   _db_switch ;;
        "/server start") ss ;;
        "/server stop") sss ;;
        "/docker up")   docker compose up -d ;;
        "/docker down") docker compose down ;;
        "/docker ps")   docker compose ps ;;
        "/cache")       cc ;;
        # Dotfiles management
        "/alias add")   _dot_add_alias ;;
        "/alias list")  cat ~/.aliases | grep "^alias" | fzf --height=40% --reverse --prompt="aliases> " --no-info --pointer=' ' --color='fg:8,fg+:15,bg+:-1,hl:6,hl+:14' ;;
        "/func add")    _dot_add_func ;;
        "/func list")   grep "^[a-z_]*() {" ~/.functions | sed 's/() {//' | fzf --height=40% --reverse --prompt="functions> " --no-info --pointer=' ' --color='fg:8,fg+:15,bg+:-1,hl:6,hl+:14' ;;
        "/dot edit")    vim ~/.dotfiles/zsh/.aliases ~/.dotfiles/zsh/.functions && source ~/.zshrc ;;
        "/dot sync")    _dot_sync ;;
        "/reload")      source ~/.zshrc && echo "Reloaded" ;;
        "/update")      dotupdate ;;
        # Setup
        "/setup claude") ~/code/claude-config/setup-claude ;;
        # Copy
        "/copy path")   _copy_to_clipboard "$(pwd)" && echo "Copied: $(pwd)" ;;
        # SSH
        "/ssh keys")    _ssh_list_keys ;;
        "/ssh agent")   ssh-add -l ;;
        "/ssh add")     _ssh_add_key ;;
        "/ssh gen")     _ssh_gen_key ;;
        "/ssh copy")    _ssh_copy_key ;;
        "/ssh config")  vim ~/.ssh/config ;;
        "/ssh connect") _ssh_connect ;;
    esac
    printf '\033[?25l'  # hide cursor immediately after command
}

# Switch database between MySQL and PostgreSQL
_db_switch() {
    local current=""
    local source_file=""

    # Check .env.local first, then .env
    if [[ -f .env.local ]] && grep -q '^DATABASE_URL=' .env.local; then
        current=$(grep '^DATABASE_URL=' .env.local | head -1)
        source_file=".env.local"
    elif [[ -f .env ]] && grep -q '^DATABASE_URL=' .env; then
        current=$(grep '^DATABASE_URL=' .env | head -1)
        source_file=".env"
    else
        echo "No DATABASE_URL found in .env.local or .env"
        return 1
    fi

    local current_type=""
    if echo "$current" | grep -q "mysql://"; then
        current_type="mysql"
    elif echo "$current" | grep -qE "(postgresql|pgsql)://"; then
        current_type="pgsql"
    else
        echo "Unknown database type in: $current"
        return 1
    fi

    local target=""
    if [[ "$current_type" == "mysql" ]]; then
        target="pgsql"
    else
        target="mysql"
    fi

    # Extract database name and query string from URL
    local dbname=$(echo "$current" | sed -E 's|.*[/@]([^?/@]+)(\?.*)?$|\1|')
    local query=$(echo "$current" | grep -o '?.*' || echo "")

    # Fix charset for target database (utf8mb4 for mysql, utf8 for pgsql)
    if [[ "$target" == "pgsql" ]]; then
        query=$(echo "$query" | sed 's/charset=utf8mb4/charset=utf8/g')
    else
        query=$(echo "$query" | sed -E 's/charset=utf8([^m]|$)/charset=utf8mb4\1/g')
    fi

    local new_url=""
    if [[ "$target" == "pgsql" ]]; then
        new_url="DATABASE_URL=pgsql://postgres:postgres@127.0.0.1/${dbname}${query}"
    else
        new_url="DATABASE_URL=mysql://root@127.0.0.1/${dbname}${query}"
    fi

    # Always save to .env.local (remove old line, append new)
    if [[ -f .env.local ]]; then
        grep -v '^DATABASE_URL=' .env.local > .env.local.tmp && mv .env.local.tmp .env.local
    fi
    echo "$new_url" >> .env.local
    echo "Switched to $target: $new_url"

    # Update .env.test.local if exists
    if [[ -f .env.test.local ]] && grep -q '^DATABASE_URL=' .env.test.local; then
        local test_current=$(grep '^DATABASE_URL=' .env.test.local | head -1)
        local test_dbname=$(echo "$test_current" | sed -E 's|.*[/@]([^?/@]+)(\?.*)?$|\1|')
        local test_query=$(echo "$test_current" | grep -o '?.*' || echo "")
        local test_new=""
        if [[ "$target" == "pgsql" ]]; then
            test_new="DATABASE_URL=pgsql://postgres:postgres@127.0.0.1/${test_dbname}${test_query}"
        else
            test_new="DATABASE_URL=mysql://root@127.0.0.1/${test_dbname}${test_query}"
        fi
        grep -v '^DATABASE_URL=' .env.test.local > .env.test.local.tmp && mv .env.test.local.tmp .env.test.local
        echo "$test_new" >> .env.test.local
        echo "Updated .env.test.local"
    fi
}

# Cross-platform clipboard
_copy_to_clipboard() {
    if command -v pbcopy &>/dev/null; then
        echo -n "$1" | pbcopy
    elif command -v xclip &>/dev/null; then
        echo -n "$1" | xclip -selection clipboard
    elif command -v xsel &>/dev/null; then
        echo -n "$1" | xsel --clipboard
    else
        echo "No clipboard tool found" >&2
        return 1
    fi
}

# SSH: List all keys
_ssh_list_keys() {
    echo "=== SSH Keys in ~/.ssh/ ==="
    for key in ~/.ssh/id_*; do
        [[ "$key" == *.pub ]] && continue
        [[ -f "$key" ]] || continue
        echo "\n$(basename $key):"
        ssh-keygen -lf "$key" 2>/dev/null
    done
}

# SSH: Add key to agent
_ssh_add_key() {
    local key=$(ls ~/.ssh/id_* 2>/dev/null | grep -v '.pub$' | fzf --height=40% --reverse --prompt="Add key: " --no-info --pointer=' ' --color='fg:8,fg+:15,bg+:-1,hl:6,hl+:14')
    [[ -n "$key" ]] && ssh-add "$key" && echo "Added: $key"
}

# SSH: Generate new key
_ssh_gen_key() {
    echo -n "Key name (e.g., id_github): "
    read name
    [[ -z "$name" ]] && return
    echo -n "Email/comment: "
    read email
    [[ -z "$email" ]] && return

    local keyfile="$HOME/.ssh/$name"
    if [[ -f "$keyfile" ]]; then
        echo "Key already exists: $keyfile"
        return 1
    fi

    ssh-keygen -t ed25519 -C "$email" -f "$keyfile"
    echo "\nPublic key:"
    cat "${keyfile}.pub"

    echo -n "\nCopy to clipboard? [Y/n] "
    read copy
    [[ ! "$copy" =~ ^[Nn]$ ]] && _copy_to_clipboard "$(cat "${keyfile}.pub")" && echo "Copied!"
}

# SSH: Copy public key to clipboard
_ssh_copy_key() {
    local key=$(ls ~/.ssh/*.pub 2>/dev/null | fzf --height=40% --reverse --prompt="Copy key: " --no-info --pointer=' ' --color='fg:8,fg+:15,bg+:-1,hl:6,hl+:14')
    if [[ -n "$key" ]]; then
        _copy_to_clipboard "$(cat "$key")"
        echo "Copied: $key"
        echo "Contents:"
        cat "$key"
    fi
}

# SSH: Connect to host from config
_ssh_connect() {
    local host=$(grep "^Host " ~/.ssh/config 2>/dev/null | awk '{print $2}' | grep -v '\*' | fzf --height=40% --reverse --prompt="SSH to: " --no-info --pointer=' ' --color='fg:8,fg+:15,bg+:-1,hl:6,hl+:14')
    [[ -n "$host" ]] && ssh "$host"
}

# Add new alias interactively
_dot_add_alias() {
    echo -n "Alias name: "
    read name
    [[ -z "$name" ]] && return
    echo -n "Command: "
    read cmd
    [[ -z "$cmd" ]] && return

    echo "alias $name='$cmd'" >> ~/.dotfiles/zsh/.aliases
    source ~/.zshrc
    echo "Added: alias $name='$cmd'"
}

# Add new function interactively
_dot_add_func() {
    echo -n "Function name: "
    read name
    [[ -z "$name" ]] && return
    echo "Enter function body (end with empty line):"

    local body=""
    while IFS= read -r line; do
        [[ -z "$line" ]] && break
        body+="    $line"$'\n'
    done

    echo "\n$name() {\n$body}" >> ~/.dotfiles/zsh/.functions
    source ~/.zshrc
    echo "Added function: $name"
}

# Sync dotfiles to remote
_dot_sync() {
    cd ~/.dotfiles
    git add -A
    git status --short
    echo -n "Commit message: "
    read msg
    [[ -z "$msg" ]] && msg="Update dotfiles"
    git commit -m "$msg"
    git push
    echo "Dotfiles synced!"
}

# ZLE widget: trigger on / at beginning of line
_slash_widget() {
    if [[ -z "$BUFFER" ]]; then
        _slash_commands
        zle -I  # invalidate display, trigger redraw
        { sleep 0.2; printf '\033[?25h'; } &!  # show cursor after delay
    else
        BUFFER+="/"
        CURSOR+=1
    fi
}
zle -N _slash_widget

# Bind / to slash widget
bindkey '/' _slash_widget

# Update dotfiles from remote
dotupdate() {
    echo "Updating dotfiles..."
    cd ~/.dotfiles && git pull

    # Restow all (in case new files added)
    stow -R zsh vim git config bash 2>/dev/null

    # Reload
    source ~/.zshrc
    echo "Done! Dotfiles updated and reloaded."
}
