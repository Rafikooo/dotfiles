# Git
wip() {
    git add .
    git commit -m "WIP"
}

gcrb() {
    [[ -z "$1" ]] && { echo "Commit hash missing"; return 1; }

    git commit --fixup=$1

    local stash_created=0
    if [[ -n "$(git status --porcelain)" ]]; then
        git stash push --keep-index -m "Stashing changes before rebase"
        stash_created=1
    fi

    GIT_SEQUENCE_EDITOR=true git rebase -i --autosquash $1^

    [[ "$stash_created" -eq 1 ]] && git stash pop
}

tagandrelease() {
    git tag -a "$1" -m "$1" && git push upstream "$1" && gh release create "$1" --generate-notes
}

untagandunrelease() {
    gh release delete "$1" --yes && git push upstream --delete "$1" && git tag -d "$1"
}

glb() {
    local branch
    branch=$(git lb | fzf --ansi --height 20 --reverse | awk '{print $NF}')
    [[ -n "$branch" ]] && git checkout "$branch"
}

# Symfony
ss() {
    APP_ENV=${1:-dev} symfony serve -d
}

sss() {
    symfony server:stop
}

cc() {
    if [[ -d "var" ]]; then
        rm -fr var/cache
        php -dxdebug.mode=off symfony console
    elif [[ -d "tests/Application" ]]; then
        cd tests/Application && rm -fr var/cache && symfony console
    else
        echo "Wrong directory"
    fi
}

dbc() {
    rm -fr private/invoices/*
    bin/console doctrine:database:drop --force --if-exists
    bin/console doctrine:database:create
    bin/console doctrine:migrations:migrate -n
    bin/console sylius:fixtures:load $1 -n
}

dbct() {
    bin/console doctrine:database:create --if-not-exists --env=test
    bin/console doctrine:schema:update --force --env=test
}

# Yarn
uberyarn() {
    rm -fr node_modules/.cache public/build
    yarn install
    yarn build
}

# Reset project
cofankolite() {
    git restore --staged .
    git restore .
    git clean -fd
}

cofanko() {
    cofankolite
    composer update
    bin/console doctrine:database:drop --if-exists --force
    bin/console doctrine:database:create --if-not-exists
    bin/console doctrine:migrations:migrate -n
}

# Xdebug
phpstorm() {
    export XDEBUG_SESSION_START=phpstorm
    export XDEBUG_CONFIG="idkey=PHPSTORM"
    export XDEBUG_SESSION=xdebug_is_great
}

xdebugoff() {
    unset XDEBUG_SESSION_START
    unset XDEBUG_CONFIG
    unset XDEBUG_SESSION
}

# Interactive env selector
setenv() {
    local env="$1"
    if [ -z "$env" ]; then
        env=$(echo -e "dev\ntest\nprod" | fzf --height=50% --prompt="APP_ENV: ")
    fi
    if [ -n "$env" ]; then
        export APP_ENV="$env"
        echo "APP_ENV=$env"
    fi
}

# Clear env (use .env defaults)
clearenv() {
    unset APP_ENV
    echo "APP_ENV cleared (using .env defaults)"
}

# Interactive database name change in .env.local
setdb() {
    [[ ! -f .env.local ]] && { echo "No .env.local found"; return 1; }

    local current=$(grep '^DATABASE_URL=' .env.local | head -1)
    echo "Current: $current"
    echo ""

    read "newdb?New database name (or empty to cancel): "
    [[ -z "$newdb" ]] && { echo "Cancelled"; return 0; }

    # Get current URL structure, replace db name
    local prefix=$(echo "$current" | sed -E 's|(DATABASE_URL=.*/)([^?]+)(.*)|\1|')
    local suffix=$(echo "$current" | sed -E 's|(DATABASE_URL=.*/)([^?]+)(.*)|\3|')

    local newline="${prefix}${newdb}${suffix}"

    # Replace in .env.local
    sed -i '' "s|^DATABASE_URL=.*|$newline|" .env.local

    echo "Updated: $newline"
}

# Interactive project menu
setup() {
    local options=(
        "xdebug: $([ -n \"$XDEBUG_SESSION\" ] && echo 'OFF' || echo 'ON')"
        "env: dev"
        "env: test"
        "env: prod"
        "env: clear"
        "db: migrate"
        "db: reset (drop + migrate + fixtures)"
        "db: set name"
        "server: start"
        "server: stop"
        "docker: up"
        "docker: down"
        "cache: clear"
    )

    local choice=$(printf '%s\n' "${options[@]}" | fzf --height=50% --reverse --prompt="setup> ")
    [[ -z "$choice" ]] && return 0

    case "$choice" in
        "xdebug: ON")  phpstorm && echo "Xdebug ON" ;;
        "xdebug: OFF") xdebugoff && echo "Xdebug OFF" ;;
        "env: dev")    export APP_ENV=dev && echo "APP_ENV=dev" ;;
        "env: test")   export APP_ENV=test && echo "APP_ENV=test" ;;
        "env: prod")   export APP_ENV=prod && echo "APP_ENV=prod" ;;
        "env: clear")  clearenv ;;
        "db: migrate") bin/console doctrine:migrations:migrate -n ;;
        "db: reset"*)  dbc ;;
        "db: set name") setdb ;;
        "server: start") ss ;;
        "server: stop")  sss ;;
        "docker: up")   docker compose up -d ;;
        "docker: down") docker compose down ;;
        "cache: clear") cc ;;
    esac
}

# Slash commands (type / at start of line)
_slash_commands() {
    local history_file="$HOME/.slash_history"
    local -A all_commands=(
        # Project commands
        ["/xdebug on"]="Enable xdebug"
        ["/xdebug off"]="Disable xdebug"
        ["/env dev"]="Set APP_ENV=dev"
        ["/env test"]="Set APP_ENV=test"
        ["/env prod"]="Set APP_ENV=prod"
        ["/env clear"]="Unset APP_ENV"
        ["/db migrate"]="Run migrations"
        ["/db reset"]="Drop + migrate + fixtures"
        ["/db name"]="Change database name"
        ["/server start"]="Start Symfony server"
        ["/server stop"]="Stop Symfony server"
        ["/docker up"]="Docker compose up -d"
        ["/docker down"]="Docker compose down"
        ["/docker ps"]="Docker compose ps"
        ["/cache"]="Clear cache"
        # Dotfiles commands
        ["/alias add"]="Add new alias"
        ["/alias list"]="Show all aliases"
        ["/func add"]="Add new function"
        ["/func list"]="Show all functions"
        ["/dot edit"]="Edit dotfiles in vim"
        ["/dot sync"]="Push dotfiles to remote"
        ["/reload"]="Reload shell config"
        ["/update"]="Update dotfiles from remote"
    )

    # Build list: recent first, then rest
    local commands=()
    local -A seen=()

    # Add recent commands first (from history)
    if [[ -f "$history_file" ]]; then
        while IFS= read -r cmd; do
            if [[ -n "${all_commands[$cmd]}" && -z "${seen[$cmd]}" ]]; then
                commands+=("$cmd:${all_commands[$cmd]}")
                seen[$cmd]=1
            fi
        done < <(tail -20 "$history_file" | tac)
    fi

    # Add remaining commands
    for cmd in "${(@k)all_commands}"; do
        if [[ -z "${seen[$cmd]}" ]]; then
            commands+=("$cmd:${all_commands[$cmd]}")
        fi
    done

    local choice=$(printf '%s\n' "${commands[@]}" | fzf --height=50% --reverse --prompt="/ " --with-nth=1 --delimiter=':' --preview='echo {2}' --preview-window=up:1 --bind='backward-eof:abort')
    local cmd=$(echo "$choice" | cut -d: -f1)

    [[ -z "$cmd" ]] && return

    # Save to history
    echo "$cmd" >> "$history_file"

    case "$cmd" in
        "/xdebug on")   phpstorm && echo "Xdebug ON" ;;
        "/xdebug off")  xdebugoff && echo "Xdebug OFF" ;;
        "/env dev")     export APP_ENV=dev && echo "APP_ENV=dev" ;;
        "/env test")    export APP_ENV=test && echo "APP_ENV=test" ;;
        "/env prod")    export APP_ENV=prod && echo "APP_ENV=prod" ;;
        "/env clear")   clearenv ;;
        "/db migrate")  bin/console doctrine:migrations:migrate -n ;;
        "/db reset")    dbc ;;
        "/db name")     setdb ;;
        "/server start") ss ;;
        "/server stop") sss ;;
        "/docker up")   docker compose up -d ;;
        "/docker down") docker compose down ;;
        "/docker ps")   docker compose ps ;;
        "/cache")       cc ;;
        # Dotfiles management
        "/alias add")   _dot_add_alias ;;
        "/alias list")  cat ~/.aliases | grep "^alias" | fzf --height=50% --reverse --prompt="aliases> " ;;
        "/func add")    _dot_add_func ;;
        "/func list")   grep "^[a-z_]*() {" ~/.functions | sed 's/() {//' | fzf --height=50% --reverse --prompt="functions> " ;;
        "/dot edit")    vim ~/.dotfiles/zsh/.aliases ~/.dotfiles/zsh/.functions && source ~/.zshrc ;;
        "/dot sync")    _dot_sync ;;
        "/reload")      source ~/.zshrc && echo "Reloaded" ;;
        "/update")      dotupdate ;;
    esac
}

# Add new alias interactively
_dot_add_alias() {
    echo -n "Alias name: "
    read name
    [[ -z "$name" ]] && return
    echo -n "Command: "
    read cmd
    [[ -z "$cmd" ]] && return

    echo "alias $name='$cmd'" >> ~/.dotfiles/zsh/.aliases
    source ~/.zshrc
    echo "Added: alias $name='$cmd'"
}

# Add new function interactively
_dot_add_func() {
    echo -n "Function name: "
    read name
    [[ -z "$name" ]] && return
    echo "Enter function body (end with empty line):"

    local body=""
    while IFS= read -r line; do
        [[ -z "$line" ]] && break
        body+="    $line"$'\n'
    done

    echo "\n$name() {\n$body}" >> ~/.dotfiles/zsh/.functions
    source ~/.zshrc
    echo "Added function: $name"
}

# Sync dotfiles to remote
_dot_sync() {
    cd ~/.dotfiles
    git add -A
    git status --short
    echo -n "Commit message: "
    read msg
    [[ -z "$msg" ]] && msg="Update dotfiles"
    git commit -m "$msg"
    git push
    echo "Dotfiles synced!"
}

# ZLE widget: trigger on / at beginning of line
_slash_widget() {
    if [[ -z "$BUFFER" ]]; then
        _slash_commands
        zle reset-prompt
    else
        BUFFER+="/"
        CURSOR+=1
    fi
}
zle -N _slash_widget

# Bind / to slash widget
bindkey '/' _slash_widget

# Update dotfiles from remote
dotupdate() {
    echo "Updating dotfiles..."
    cd ~/.dotfiles && git pull

    # Restow all (in case new files added)
    stow -R zsh vim git config bash 2>/dev/null

    # Reload
    source ~/.zshrc
    echo "Done! Dotfiles updated and reloaded."
}
